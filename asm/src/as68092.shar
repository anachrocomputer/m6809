#!/bin/sh
# This is part 02 of Frankasm/As6809
# ============= as6809.y ==============
if test -f 'as6809.y' -a X"$1" != X"-c"; then
	echo 'x - skipping as6809.y (File already exists)'
else
echo 'x - extracting as6809.y (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'as6809.y' &&
X%{
X
X/*
XHEADER: 	;
XTITLE: 		Frankenstein Cross Assemblers;
XVERSION: 	2.0;
XDESCRIPTION: "	Reconfigurable Cross-assembler producing Intel (TM)
X		Hex format object records.  ";
XKEYWORDS: 	cross-assemblers, 1805, 2650, 6301, 6502, 6805, 6809, 
X		6811, tms7000, 8048, 8051, 8096, z8, z80;
XSYSTEM: 	UNIX, MS-Dos ;
XFILENAME: 	as6809.y;
XWARNINGS: 	"This software is in the public domain.  
X		Any prior copyright claims are relinquished.  
X
X		This software is distributed with no warranty whatever.  
X		The author takes no responsibility for the consequences 
X		of its use.
X
X		Yacc (or Bison) required to compile."  ;
XSEE-ALSO: 	as6809.doc,frasmain.c;	
XAUTHORS: 	Mark Zenier;
XCOMPILERS: 	Microport Sys V/AT, ATT Yacc, Turbo C V1.5, Bison (CUG disk 285)
X		(previous versions Xenix, Unisoft 68000 Version 7, Sun 3);
X*/
X/* 6809 instruction generation file */
X/* November 17, 1990 */
X
X/*
X	description	frame work parser description for framework cross
X			assemblers
X	history		February 2, 1988
X			September 11, 1990 - merge table definition
X			September 12, 1990 - short file names
X			September 14, 1990 - short variable names
X			September 17, 1990 - use yylex as external
X*/
X#include <stdio.h>
X#include "frasmdat.h"
X#include "fragcon.h"
X
X#define yylex lexintercept
X
X	/* select criteria for ST_EXP  0000.0000.0000.00xx */
X#define	ADDR	0x3
X#define	DIRECT	0x1
X#define	EXTENDED	0x2
X#define ST_INH 0x1
X#define ST_IMM 0x2
X#define ST_EXP 0x4
X#define ST_IND 0x8
X#define ST_PCR 0x10
X#define ST_IPCR 0x20
X#define ST_IEXPR 0x40
X#define ST_SPSH 0x1
X#define ST_UPSH 0x1
X#define ST_TFR 0x1
X	
X	static char	genbdef[] = "[1=];";
X	static char	genwdef[] = "[1=]x"; /* x for normal, y for byte rev */
X	char ignosyn[] = "[Xinvalid syntax for instruction";
X	char ignosel[] = "[Xinvalid operands";
X#define	IDM000	0
X#define	IDM100	1
X#define	IDM101	2
X#define	IDM102	3
X#define	IDM103	4
X#define	IDM104	5
X#define	IDM105	6
X#define	IDM106	7
X#define	IDM108	8
X#define	IDM109	9
X#define	IDM10B	10
X#define	IDM111	11
X#define	IDM113	12
X#define	IDM114	13
X#define	IDM115	14
X#define	IDM116	15
X#define	IDM118	16
X#define	IDM119	17
X#define	IDM11B	18
X	char *(indexgen [] [4]) = {
X/*IDM000;*/ { "[1=].5R.00|;", "[1=].5R.20|;", "[1=].5R.40|;", "[1=].5R.60|;"},
X/*IDM100;*/ { "80;", "a0;", "c0;", "e0;" },
X/*IDM101;*/ { "81;", "a1;", "c1;", "e1;" },
X/*IDM102;*/ { "82;", "a2;", "c2;", "e2;" },
X/*IDM103;*/ { "83;", "a3;", "c3;", "e3;" },
X/*IDM104;*/ { "84;", "a4;", "c4;", "e4;" },
X/*IDM105;*/ { "85;", "a5;", "c5;", "e5;" },
X/*IDM106;*/ { "86;", "a6;", "c6;", "e6;" },
X/*IDM108;*/ { "88;[1=]r", "a8;[1=]r", "c8;[1=]r", "e8;[1=]r" },
X/*IDM109;*/ { "89;[1=]x", "a9;[1=]x", "c9;[1=]x", "e9;[1=]x" },
X/*IDM10B;*/ { "8B;", "aB;", "cB;", "eB;" },
X/*IDM111;*/ { "91;", "B1;", "D1;", "F1;" },
X/*IDM113;*/ { "93;", "B3;", "D3;", "F3;" },
X/*IDM114;*/ { "94;", "B4;", "D4;", "F4;" },
X/*IDM115;*/ { "95;", "B5;", "D5;", "F5;" },
X/*IDM116;*/ { "96;", "B6;", "D6;", "F6;" },
X/*IDM118;*/ { "98;[1=]r", "b8;[1=]r", "d8;[1=]r", "f8;[1=]r" },
X/*IDM119;*/ { "99;[1=]x", "b9;[1=]x", "d9;[1=]x", "f9;[1=]x" },
X/*IDM11B;*/ { "9B;", "BB;", "DB;", "FB;" }
X		};
X
X#define	PCRNEG8M	-126
X#define	PCRPLUS8M	129
X#define	PCR8STR		"8c;[1=].Q.1+-r"
X#define	IPCR8STR	"9c;[1=].Q.1+-r"
X#define	PCR16STR	"8d;[1=].Q.2+-.ffff&x"
X#define	IPCR16STR	"9d;[1=].Q.2+-.ffff&x"
X#define	IEXPSTR		"9f;[1=]x"
X#define	TFRD	0
X#define	TFRX	1
X#define	TFRY	2
X#define	TFRU	3
X#define	TFRS	4
X#define	TFRPC	5
X#define	TFRA	0x8
X#define	TFRB	0x9
X#define	TFRCC	0xa
X#define	TFRDP	0xb
X#define	TFR8BIT	0x8
X#define	REGBUSTK 0x100
X#define	REGBSSTK 0x200
X#define	PPOSTCC	0x01
X#define	PPOSTA	0x02
X#define	PPOSTB	0x04
X#define	PPOSTDP	0x08
X#define	PPOSTX	0x10
X#define	PPOSTY	0x20
X#define	PPOSTS	(0x40|REGBSSTK)
X#define	PPOSTU	(0x40|REGBUSTK)
X#define	PPOSTPC	0x80
X
X	long	labelloc;
X	static int satsub;
X	int	ifstkpt = 0;
X	int	fraifskip = FALSE;
X
X	struct symel * endsymbol = SYMNULL;
X
X%}
X%union {
X	int	intv;
X	long 	longv;
X	char	*strng;
X	struct symel *symb;
X}
X
X%token <intv> ACCUM
X%token <intv> INDEX
X%token <intv> SPECREG
X%token  PCRELATIVE
X%type <intv> regbits register
X%type <strng> indexed
X%token <intv> KOC_BDEF
X%token <intv> KOC_ELSE
X%token <intv> KOC_END
X%token <intv> KOC_ENDI
X%token <intv> KOC_EQU
X%token <intv> KOC_IF
X%token <intv> KOC_INCLUDE
X%token <intv> KOC_ORG
X%token <intv> KOC_RESM
X%token <intv> KOC_SDEF
X%token <intv> KOC_SET
X%token <intv> KOC_WDEF
X%token <intv> KOC_CHSET
X%token <intv> KOC_CHDEF
X%token <intv> KOC_CHUSE
X%token <intv> KOC_opcode
X%token <intv> KOC_sstkop
X%token <intv> KOC_ustkop
X%token <intv> KOC_tfrop
X
X%token <longv> CONSTANT
X%token EOL
X%token KEOP_AND
X%token KEOP_DEFINED
X%token KEOP_EQ
X%token KEOP_GE
X%token KEOP_GT
X%token KEOP_HIGH
X%token KEOP_LE
X%token KEOP_LOW
X%token KEOP_LT
X%token KEOP_MOD
X%token KEOP_MUN
X%token KEOP_NE
X%token KEOP_NOT
X%token KEOP_OR
X%token KEOP_SHL
X%token KEOP_SHR
X%token KEOP_XOR
X%token KEOP_locctr
X%token <symb> LABEL
X%token <strng> STRING
X%token <symb> SYMBOL
X
X%token KTK_invalid
X
X%right	KEOP_HIGH KEOP_LOW
X%left	KEOP_OR KEOP_XOR
X%left	KEOP_AND
X%right	KEOP_NOT
X%nonassoc	KEOP_GT KEOP_GE KEOP_LE KEOP_LT KEOP_NE KEOP_EQ
X%left	'+' '-'
X%left	'*' '/' KEOP_MOD KEOP_SHL KEOP_SHR
X%right	KEOP_MUN
X
X
X%type <intv> expr exprlist stringlist
X
X%start file
X
X%%
X
Xfile	:	file allline
X	|	allline
X	;
X
Xallline	: 	line EOL
X			{
X				clrexpr();
X			}
X	|	EOL
X	|	error EOL
X			{
X				clrexpr();
X				yyerrok;
X			}
X	;
X
Xline	:	LABEL KOC_END 
X			{
X				endsymbol = $1;
X				nextreadact = Nra_end;
X			}
X	|	      KOC_END 
X			{
X				nextreadact = Nra_end;
X			}
X	|	KOC_INCLUDE STRING
X			{
X		if(nextfstk >= FILESTKDPTH)
X		{
X			fraerror("include file nesting limit exceeded");
X		}
X		else
X		{
X			infilestk[nextfstk].fnm = savestring($2,strlen($2));
X			if( (infilestk[nextfstk].fpt = fopen($2,"r"))
X				==(FILE *)NULL )
X			{
X				fraerror("cannot open include file");
X			}
X			else
X			{
X				nextreadact = Nra_new;
X			}
X		}
X			}
X	|	LABEL KOC_EQU expr 
X			{
X				if($1 -> seg == SSG_UNDEF)
X				{
X					pevalexpr(0, $3);
X					if(evalr[0].seg == SSG_ABS)
X					{
X						$1 -> seg = SSG_EQU;
X						$1 -> value = evalr[0].value;
X						prtequvalue("C: 0x%lx\n",
X							evalr[0].value);
X					}
X					else
X					{
X						fraerror(
X					"noncomputable expression for EQU");
X					}
X				}
X				else
X				{
X					fraerror(
X				"cannot change symbol value with EQU");
X				}
X			}
X	|	LABEL KOC_SET expr 
X			{
X				if($1 -> seg == SSG_UNDEF
X				   || $1 -> seg == SSG_SET)
X				{
X					pevalexpr(0, $3);
X					if(evalr[0].seg == SSG_ABS)
X					{
X						$1 -> seg = SSG_SET;
X						$1 -> value = evalr[0].value;
X						prtequvalue("C: 0x%lx\n",
X							evalr[0].value);
X					}
X					else
X					{
X						fraerror(
X					"noncomputable expression for SET");
X					}
X				}
X				else
X				{
X					fraerror(
X				"cannot change symbol value with SET");
X				}
X			}
X	|	KOC_IF expr 
X			{
X		if((++ifstkpt) < IFSTKDEPTH)
X		{
X			pevalexpr(0, $2);
X			if(evalr[0].seg == SSG_ABS)
X			{
X				if(evalr[0].value != 0)
X				{
X					elseifstk[ifstkpt] = If_Skip;
X					endifstk[ifstkpt] = If_Active;
X				}
X				else
X				{
X					fraifskip = TRUE;
X					elseifstk[ifstkpt] = If_Active;
X					endifstk[ifstkpt] = If_Active;
X				}
X			}
X			else
X			{
X				fraifskip = TRUE;
X				elseifstk[ifstkpt] = If_Active;
X				endifstk[ifstkpt] = If_Active;
X			}
X		}
X		else
X		{
X			fraerror("IF stack overflow");
X		}
X			}
X						
X	|	KOC_IF 
X			{
X		if(fraifskip) 
X		{
X			if((++ifstkpt) < IFSTKDEPTH)
X			{
X					elseifstk[ifstkpt] = If_Skip;
X					endifstk[ifstkpt] = If_Skip;
X			}
X			else
X			{
X				fraerror("IF stack overflow");
X			}
X		}
X		else
X		{
X			yyerror("syntax error");
X			YYERROR;
X		}
X				}
X						
X	|	KOC_ELSE 
X			{
X				switch(elseifstk[ifstkpt])
X				{
X				case If_Active:
X					fraifskip = FALSE;
X					break;
X				
X				case If_Skip:
X					fraifskip = TRUE;
X					break;
X				
X				case If_Err:
X					fraerror("ELSE with no matching if");
X					break;
X				}
X			}
X
X	|	KOC_ENDI 
X			{
X				switch(endifstk[ifstkpt])
X				{
X				case If_Active:
X					fraifskip = FALSE;
X					ifstkpt--;
X					break;
X				
X				case If_Skip:
X					fraifskip = TRUE;
X					ifstkpt--;
X					break;
X				
X				case If_Err:
X					fraerror("ENDI with no matching if");
X					break;
X				}
X			}
X	|	LABEL KOC_ORG expr 
X			{
X				pevalexpr(0, $3);
X				if(evalr[0].seg == SSG_ABS)
X				{
X					locctr = labelloc = evalr[0].value;
X					if($1 -> seg == SSG_UNDEF)
X					{
X						$1 -> seg = SSG_ABS;
X						$1 -> value = labelloc;
X					}
X					else
X						fraerror(
X						"multiple definition of label");
X					prtequvalue("C: 0x%lx\n",
X						evalr[0].value);
X				}
X				else
X				{
X					fraerror(
X					 "noncomputable expression for ORG");
X				}
X			}
X	|	      KOC_ORG expr 
X			{
X				pevalexpr(0, $2);
X				if(evalr[0].seg == SSG_ABS)
X				{
X					locctr = labelloc = evalr[0].value;
X					prtequvalue("C: 0x%lx\n",
X						evalr[0].value);
X				}
X				else
X				{
X					fraerror(
X					 "noncomputable expression for ORG");
X				}
X			}
X	|	LABEL KOC_CHSET
X			{
X				if($1 -> seg == SSG_UNDEF)
X				{
X					$1 -> seg = SSG_EQU;
X					if( ($1->value = chtcreate()) <= 0)
X					{
X		fraerror( "cannot create character translation table");
X					}
X					prtequvalue("C: 0x%lx\n", $1 -> value);
X				}
X				else
X				{
X			fraerror( "multiple definition of label");
X				}
X			}
X	|		KOC_CHUSE
X			{
X				chtcpoint = (int *) NULL;
X				prtequvalue("C: 0x%lx\n", 0L);
X			}
X	|		KOC_CHUSE expr
X			{
X				pevalexpr(0, $2);
X				if( evalr[0].seg == SSG_ABS)
X				{
X					if( evalr[0].value == 0)
X					{
X						chtcpoint = (int *)NULL;
X						prtequvalue("C: 0x%lx\n", 0L);
X					}
X					else if(evalr[0].value < chtnxalph)
X					{
X				chtcpoint = chtatab[evalr[0].value];
X				prtequvalue("C: 0x%lx\n", evalr[0].value);
X					}
X					else
X					{
X			fraerror("nonexistent character translation table");
X					}
X				}
X				else
X				{
X					fraerror("noncomputable expression");
X				}
X			}
X	|		KOC_CHDEF STRING ',' exprlist
X			{
X		int findrv, numret, *charaddr;
X		char *sourcestr = $2, *before;
X
X		if(chtnpoint != (int *)NULL)
X		{
X			for(satsub = 0; satsub < $4; satsub++)
X			{
X				before = sourcestr;
X
X				pevalexpr(0, exprlist[satsub]);
X				findrv = chtcfind(chtnpoint, &sourcestr,
X						&charaddr, &numret);
X				if(findrv == CF_END)
X				{
X			fraerror("more expressions than characters");
X					break;
X				}
X
X				if(evalr[0].seg == SSG_ABS)
X				{
X					switch(findrv)
X					{
X					case CF_UNDEF:
X						{
X				if(evalr[0].value < 0 ||
X					evalr[0].value > 255)
X				{
X			frawarn("character translation value truncated");
X				}
X				*charaddr = evalr[0].value & 0xff;
X				prtequvalue("C: 0x%lx\n", evalr[0].value);
X						}
X						break;
X
X					case CF_INVALID:
X					case CF_NUMBER:
X				fracherror("invalid character to define", 
X					before, sourcestr);
X						break;
X
X					case CF_CHAR:
X				fracherror("character already defined", 
X					before, sourcestr);
X						break;
X					}
X				}
X				else
X				{
X					fraerror("noncomputable expression");
X				}
X			}
X
X			if( *sourcestr != '\0')
X			{
X				fraerror("more characters than expressions");
X			}
X		}
X		else
X		{
X			fraerror("no CHARSET statement active");
X		}
X			
X			}
X	|	LABEL 
X			{
X			if($1 -> seg == SSG_UNDEF)
X			{
X				$1 -> seg = SSG_ABS;
X				$1 -> value = labelloc;
X				prtequvalue("C: 0x%lx\n", labelloc);
X
X			}
X			else
X				fraerror(
X				"multiple definition of label");
X			}
X	|	labeledline
X	;
X
Xlabeledline :	LABEL genline
X			{
X			if($1 -> seg == SSG_UNDEF)
X			{
X				$1 -> seg = SSG_ABS;
X				$1 -> value = labelloc;
X			}
X			else
X				fraerror(
X				"multiple definition of label");
X			labelloc = locctr;
X			}
X				
X	|	genline
X			{
X				labelloc = locctr;
X			}
X	;
X
Xgenline	:	KOC_BDEF	exprlist 
X			{
X				genlocrec(currseg, labelloc);
X				for( satsub = 0; satsub < $2; satsub++)
X				{
X					pevalexpr(1, exprlist[satsub]);
X					locctr += geninstr(genbdef);
X				}
X			}
X	|	KOC_SDEF stringlist 
X			{
X				genlocrec(currseg, labelloc);
X				for(satsub = 0; satsub < $2; satsub++)
X				{
X					locctr += genstring(stringlist[satsub]);
X				}
X			}
X	|	KOC_WDEF exprlist 
X			{
X				genlocrec(currseg, labelloc);
X				for( satsub = 0; satsub < $2; satsub++)
X				{
X					pevalexpr(1, exprlist[satsub]);
X					locctr += geninstr(genwdef);
X				}
X			}	
X	|	KOC_RESM expr 
X			{
X				pevalexpr(0, $2);
X				if(evalr[0].seg == SSG_ABS)
X				{
X					locctr = labelloc + evalr[0].value;
X					prtequvalue("C: 0x%lx\n", labelloc);
X				}
X				else
X				{
X					fraerror(
X				 "noncomputable result for RMB expression");
X				}
X			}
X	;
X
Xexprlist :	exprlist ',' expr
X			{
X				exprlist[nextexprs ++ ] = $3;
X				$$ = nextexprs;
X			}
X	|	expr
X			{
X				nextexprs = 0;
X				exprlist[nextexprs ++ ] = $1;
X				$$ = nextexprs;
X			}
X	;
X
Xstringlist :	stringlist ',' STRING
X			{
X				stringlist[nextstrs ++ ] = $3;
X				$$ = nextstrs;
X			}
X	|	STRING
X			{
X				nextstrs = 0;
X				stringlist[nextstrs ++ ] = $1;
X				$$ = nextstrs;
X			}
X	;
X
X
Xgenline : KOC_opcode  
X			{
X		genlocrec(currseg, labelloc);
X		locctr += geninstr(findgen($1, ST_INH, 0));
X			}
X	;
Xgenline : KOC_opcode  '#' expr
X			{
X		pevalexpr(1, $3);
X		genlocrec(currseg, labelloc);
X		locctr += geninstr( findgen($1, ST_IMM, 0));
X			}
X	;
Xgenline : KOC_opcode  expr
X			{
X		genlocrec(currseg, labelloc);
X		pevalexpr(1, $2);
X		locctr += geninstr( findgen( $1, ST_EXP, 
X				  ( (evalr[1].seg == SSG_ABS 
X				&& evalr[1].value >= 0
X				&& evalr[1].value <= 255 )
X				? DIRECT : EXTENDED ) )
X				);
X			}
X	;
Xgenline : KOC_opcode  indexed
X			{
X		genlocrec(currseg, labelloc);
X		locctr += geninstr(findgen($1, ST_IND, 0));
X		locctr += geninstr($2);
X			}
X	;
Xgenline : KOC_opcode  expr ',' PCRELATIVE
X			{
X		genlocrec(currseg, labelloc);
X		pevalexpr(1, $2);
X		locctr += geninstr(findgen($1, ST_IND, 0));
X		if(evalr[1].seg == SSG_ABS 
X			&& (evalr[1].value - locctr) >= PCRNEG8M
X			&& (evalr[1].value - locctr) <= PCRPLUS8M)
X		{
X			locctr += geninstr(PCR8STR);
X		}
X		else
X		{
X			locctr += geninstr(PCR16STR);
X		}
X			}
X	;
Xgenline : KOC_opcode  '[' expr ',' PCRELATIVE ']'
X			{
X		genlocrec(currseg, labelloc);
X		pevalexpr(1, $3);
X		locctr += geninstr(findgen($1, ST_IND, 0));
X		if(evalr[1].seg == SSG_ABS 
X			&& (evalr[1].value - locctr) >= PCRNEG8M
X			&& (evalr[1].value - locctr) <= PCRPLUS8M)
X		{
X			locctr += geninstr(IPCR8STR);
X		}
X		else
X		{
X			locctr += geninstr(IPCR16STR);
X		}
X			}
X	;
Xgenline : KOC_opcode  '[' expr ']'
X			{
X		genlocrec(currseg, labelloc);
X		pevalexpr(1, $3);
X		locctr += geninstr(findgen($1, ST_IND, 0));
X		locctr += geninstr(IEXPSTR);
X			}
X	;
Xgenline : KOC_sstkop  regbits
X			{
X		genlocrec(currseg, labelloc);
X		if($2 & REGBSSTK)
X		{
X			fraerror("push/pop of system stack register");
X			evalr[1].value = 0;
X		}
X		else
X		{
X			evalr[1].value = $2 & 0xff;
X		}	
X		locctr += geninstr(findgen($1, ST_SPSH, 0));
X			}
X	;
Xgenline : KOC_ustkop  regbits
X			{
X		genlocrec(currseg, labelloc);
X		if($2 & REGBUSTK)
X		{
X			fraerror("push/pop of user stack register");
X			evalr[1].value = 0;
X		}
X		else
X		{
X			evalr[1].value = $2 & 0xff;
X		}	
X		locctr += geninstr(findgen($1, ST_SPSH, 0));
X			}
X	;
Xgenline : KOC_tfrop  register ',' register
X			{
X		genlocrec(currseg, labelloc);
X		if(($2 & TFR8BIT) == ($4 & TFR8BIT))
X		{
X			evalr[1].value = $2;
X			evalr[2].value = $4;
X		}
X		else
X		{
X			evalr[1].value = 0;
X			evalr[2].value = 0;
X			fraerror("operands are different sizes");
X		}
X		locctr += geninstr(findgen($1, ST_TFR, 0));
X			}
X	;
Xindexed :	expr ',' INDEX
X			{
X		pevalexpr(1, $1);
X		if(evalr[1].seg == SSG_ABS
X			&& evalr[1].value >= -128
X			&& evalr[1].value <= 127 )
X		{
X			if(evalr[1].value >= -16
X			&& evalr[1].value <= 15)
X			{
X				if(evalr[1].value == 0)
X					$$ = indexgen [IDM104] [$3 - TFRX];
X				else
X					$$ = indexgen [IDM000] [$3 - TFRX];
X			}
X			else
X			{
X				$$ = indexgen [IDM108] [$3 - TFRX];
X			}
X		}
X		else
X		{
X			$$ = indexgen [IDM109] [$3 - TFRX];
X		}
X			}
X
X	|	ACCUM ',' INDEX
X			{
X		switch($1)
X		{
X		case TFRA:
X			$$ = indexgen [IDM106] [$3 - TFRX];
X			break;
X		case TFRB:
X			$$ = indexgen [IDM105] [$3 - TFRX];
X			break;
X		case TFRD:
X			$$ = indexgen [IDM10B] [$3 - TFRX];
X			break;
X		}
X			}
X
X	|	',' INDEX
X			{
X		$$ = indexgen [IDM104] [$2 - TFRX];
X			}
X
X	|	',' INDEX '+'
X			{
X		$$ = indexgen [IDM100] [$2 - TFRX];
X			}
X
X	|	',' INDEX '+' '+'
X			{
X		$$ = indexgen [IDM101] [$2 - TFRX];
X			}
X
X	|	',' '-' INDEX
X			{
X		$$ = indexgen [IDM102] [$3 - TFRX];
X			}
X
X	|	',' '-' '-' INDEX
X			{
X		$$ = indexgen [IDM103] [$4 - TFRX];
X			}
X
X	|	'[' expr ',' INDEX ']'
X			{
X		pevalexpr(1, $2);
X		if(evalr[1].seg == SSG_ABS
X			&& evalr[1].value >= -128
X			&& evalr[1].value <= 127 )
X		{
X			if(evalr[1].value == 0)
X				$$ = indexgen [IDM114] [$4 - TFRX];
X			else
X				$$ = indexgen [IDM118] [$4 - TFRX];
X		}
X		else
X		{
X			$$ = indexgen [IDM119] [$4 - TFRX];
X		}
X			}
X
X	|	'[' ACCUM ',' INDEX ']'
X			{
X		switch($2)
X		{
X		case TFRA:
X			$$ = indexgen [IDM116] [$4 - TFRX];
X			break;
X		case TFRB:
X			$$ = indexgen [IDM115] [$4 - TFRX];
X			break;
X		case TFRD:
X			$$ = indexgen [IDM11B] [$4 - TFRX];
X			break;
X		}
X			}
X
X	|	'[' ',' INDEX ']'
X			{
X		$$ = indexgen [IDM114] [$3 - TFRX];
X			}
X
X	|	'[' ',' INDEX '+' '+' ']'
X			{
X		$$ = indexgen [IDM111] [$3 - TFRX];
X			}
X
X	|	'[' ',' '-' '-' INDEX ']'
X			{
X		$$ = indexgen [IDM113] [$5 - TFRX];
X			}
X	;
X
Xregbits :	regbits ',' register
X			{
X		switch($3)
X		{
X		case TFRD:
X			$$ = $1 |  (PPOSTA | PPOSTB);
X			break;
X		case TFRX:
X			$$ = $1 |  PPOSTX;
X			break;
X		case TFRY:
X			$$ = $1 |  PPOSTY;
X			break;
X		case TFRU:
X			$$ = $1 |  PPOSTU;
X			break;
X		case TFRS:
X			$$ = $1 |  PPOSTS;
X			break;
X		case TFRPC:
X			$$ = $1 |  PPOSTPC;
X			break;
X		case TFRA:
X			$$ = $1 |  PPOSTA;
X			break;
X		case TFRB:
X			$$ = $1 |  PPOSTB;
X			break;
X		case TFRCC:
X			$$ = $1 |  PPOSTCC;
X			break;
X		case TFRDP:
X			$$ = $1 |  PPOSTDP;
X			break;
X		}
X			}
X	|	register
X			{
X		switch($1)
X		{
X		case TFRD:
X			$$ = (PPOSTA | PPOSTB);
X			break;
X		case TFRX:
X			$$ = PPOSTX;
X			break;
X		case TFRY:
X			$$ = PPOSTY;
X			break;
X		case TFRU:
X			$$ = PPOSTU;
X			break;
X		case TFRS:
X			$$ = PPOSTS;
X			break;
X		case TFRPC:
X			$$ = PPOSTPC;
X			break;
X		case TFRA:
X			$$ = PPOSTA;
X			break;
X		case TFRB:
X			$$ = PPOSTB;
X			break;
X		case TFRCC:
X			$$ = PPOSTCC;
X			break;
X		case TFRDP:
X			$$ = PPOSTDP;
X			break;
X		}
X			}
X	;
X
Xregister :	ACCUM
X	|	INDEX
X	|	SPECREG
X	;
Xexpr	:	'+' expr %prec KEOP_MUN
X			{
X				$$ = $2;
X			}
X	|	'-' expr %prec KEOP_MUN
X			{
X				$$ = exprnode(PCCASE_UN,$2,IFC_NEG,0,0L,
X					SYMNULL);
X			}
X	|	KEOP_NOT expr
X			{
X				$$ = exprnode(PCCASE_UN,$2,IFC_NOT,0,0L,
X					SYMNULL);
X			}
X	|	KEOP_HIGH expr
X			{
X				$$ = exprnode(PCCASE_UN,$2,IFC_HIGH,0,0L,
X					SYMNULL);
X			}
X	|	KEOP_LOW expr
X			{
X				$$ = exprnode(PCCASE_UN,$2,IFC_LOW,0,0L,
X					SYMNULL);
X			}
X	|	expr '*' expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_MUL,$3,0L,
X					SYMNULL);
X			}
X	|	expr '/' expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_DIV,$3,0L,
X					SYMNULL);
X			}
X	|	expr '+' expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_ADD,$3,0L,
X					SYMNULL);
X			}
X	|	expr '-' expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_SUB,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_MOD expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_MOD,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_SHL expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_SHL,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_SHR expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_SHR,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_GT expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_GT,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_GE expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_GE,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_LT expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_LT,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_LE expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_LE,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_NE expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_NE,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_EQ expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_EQ,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_AND expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_AND,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_OR expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_OR,$3,0L,
X					SYMNULL);
X			}
X	|	expr KEOP_XOR expr
X			{
X				$$ = exprnode(PCCASE_BIN,$1,IFC_XOR,$3,0L,
X					SYMNULL);
X			}
X	|	KEOP_DEFINED SYMBOL
X			{
X				$$ = exprnode(PCCASE_DEF,0,IGP_DEFINED,0,0L,$2);
X			}
X	|	SYMBOL
X			{
X				$$ = exprnode(PCCASE_SYMB,0,IFC_SYMB,0,0L,$1);
X			}
X	|	'*'
X			{
X				$$ = exprnode(PCCASE_PROGC,0,IFC_PROGCTR,0,
X					labelloc, SYMNULL);
X			}
X	|	CONSTANT
X			{
X				$$ = exprnode(PCCASE_CONS,0,IGP_CONSTANT,0,$1,
X					SYMNULL);
X			}
X	|	STRING
X			{
X				char *sourcestr = $1;
X				long accval = 0;
X
X				if(strlen($1) > 0)
X				{
X					accval = chtran(&sourcestr);
X					if(*sourcestr != '\0')
X					{
X						accval = (accval << 8) +
X							chtran(&sourcestr);
X					}
X
X					if( *sourcestr != '\0')
X					{
X	frawarn("string constant in expression more than 2 characters long");
X					}
X				}
X				$$ = exprnode(PCCASE_CONS, 0, IGP_CONSTANT, 0,
X					accval, SYMNULL);
X			}
X	|	'(' expr ')'
X			{
X				$$ = $2;
X			}
X	;
X
X
X
X%%
X
Xlexintercept()
X/*
X	description	intercept the call to yylex (the lexical analyzer)
X			and filter out all unnecessary tokens when skipping
X			the input between a failed IF and its matching ENDI or
X			ELSE
X	globals 	fraifskip	the enable flag
X*/
X{
X#undef yylex
X
X	int rv;
X
X	if(fraifskip)
X	{
X		for(;;)
X		{
X
X			switch(rv = yylex())
X
X			{
X			case 0:
X			case KOC_END:
X			case KOC_IF:
X			case KOC_ELSE:
X			case KOC_ENDI:
X			case EOL:
X				return rv;
X			default:
X				break;
X			}
X		}
X	}
X	else
X		return yylex();
X#define yylex lexintercept
X}
X
X
X
Xsetreserved()
X{
X
X	reservedsym("and", KEOP_AND, 0);
X	reservedsym("defined", KEOP_DEFINED,0);
X	reservedsym("eq", KEOP_EQ, 0);
X	reservedsym("ge", KEOP_GE, 0);
X	reservedsym("gt", KEOP_GT, 0);
X	reservedsym("high", KEOP_HIGH, 0);
X	reservedsym("le", KEOP_LE, 0);
X	reservedsym("low", KEOP_LOW, 0);
X	reservedsym("lt", KEOP_LT, 0);
X	reservedsym("mod", KEOP_MOD, 0);
X	reservedsym("ne", KEOP_NE, 0);
X	reservedsym("not", KEOP_NOT, 0);
X	reservedsym("or", KEOP_OR, 0);
X	reservedsym("shl", KEOP_SHL, 0);
X	reservedsym("shr", KEOP_SHR, 0);
X	reservedsym("xor", KEOP_XOR, 0);
X	reservedsym("AND", KEOP_AND, 0);
X	reservedsym("DEFINED", KEOP_DEFINED,0);
X	reservedsym("EQ", KEOP_EQ, 0);
X	reservedsym("GE", KEOP_GE, 0);
X	reservedsym("GT", KEOP_GT, 0);
X	reservedsym("HIGH", KEOP_HIGH, 0);
X	reservedsym("LE", KEOP_LE, 0);
X	reservedsym("LOW", KEOP_LOW, 0);
X	reservedsym("LT", KEOP_LT, 0);
X	reservedsym("MOD", KEOP_MOD, 0);
X	reservedsym("NE", KEOP_NE, 0);
X	reservedsym("NOT", KEOP_NOT, 0);
X	reservedsym("OR", KEOP_OR, 0);
X	reservedsym("SHL", KEOP_SHL, 0);
X	reservedsym("SHR", KEOP_SHR, 0);
X	reservedsym("XOR", KEOP_XOR, 0);
X
X	/* machine specific token definitions */
X	reservedsym("a", ACCUM, TFRA);
X	reservedsym("b", ACCUM, TFRB);
X	reservedsym("cc", SPECREG, TFRCC);
X	reservedsym("dp", SPECREG, TFRDP);
X	reservedsym("d", ACCUM, TFRD);
X	reservedsym("x", INDEX, TFRX);
X	reservedsym("y", INDEX, TFRY);
X	reservedsym("u", INDEX, TFRU);
X	reservedsym("s", INDEX, TFRS);
X	reservedsym("pc", SPECREG, TFRPC);
X	reservedsym("pcr", PCRELATIVE, 0);
X	reservedsym("A", ACCUM, TFRA);
X	reservedsym("B", ACCUM, TFRB);
X	reservedsym("CC", SPECREG, TFRCC);
X	reservedsym("DP", SPECREG, TFRDP);
X	reservedsym("D", ACCUM, TFRD);
X	reservedsym("X", INDEX, TFRX);
X	reservedsym("Y", INDEX, TFRY);
X	reservedsym("U", INDEX, TFRU);
X	reservedsym("S", INDEX, TFRS);
X	reservedsym("PC", SPECREG, TFRPC);
X	reservedsym("PCR", PCRELATIVE, 0);
X}
X
Xcpumatch(str)
X	char * str;
X{
X	return TRUE;
X}
X
X/*
X	description	Opcode and Instruction generation tables
X	usage		Unix, framework crossassembler
X	history		September 25, 1987
X*/
X
X#define NUMOPCODE 163
X#define NUMSYNBLK 226
X#define NUMDIFFOP 279
X
Xint gnumopcode = NUMOPCODE;
X
Xint ophashlnk[NUMOPCODE];
X
Xstruct opsym optab[NUMOPCODE+1]
X	= {
X	{"invalid", KOC_opcode, 2, 0 },
X	{"ABX", KOC_opcode, 1, 2 },
X	{"ADCA", KOC_opcode, 3, 3 },
X	{"ADCB", KOC_opcode, 3, 6 },
X	{"ADDA", KOC_opcode, 3, 9 },
X	{"ADDB", KOC_opcode, 3, 12 },
X	{"ADDD", KOC_opcode, 3, 15 },
X	{"ANDA", KOC_opcode, 3, 18 },
X	{"ANDB", KOC_opcode, 3, 21 },
X	{"ANDCC", KOC_opcode, 1, 24 },
X	{"ASL", KOC_opcode, 2, 25 },
X	{"ASLA", KOC_opcode, 1, 27 },
X	{"ASLB", KOC_opcode, 1, 28 },
X	{"ASR", KOC_opcode, 2, 29 },
X	{"ASRA", KOC_opcode, 1, 31 },
X	{"ASRB", KOC_opcode, 1, 32 },
X	{"BCC", KOC_opcode, 1, 33 },
X	{"BCS", KOC_opcode, 1, 34 },
X	{"BEQ", KOC_opcode, 1, 35 },
X	{"BGE", KOC_opcode, 1, 36 },
X	{"BGT", KOC_opcode, 1, 37 },
X	{"BHI", KOC_opcode, 1, 38 },
X	{"BHS", KOC_opcode, 1, 39 },
X	{"BITA", KOC_opcode, 3, 40 },
X	{"BITB", KOC_opcode, 3, 43 },
X	{"BLE", KOC_opcode, 1, 46 },
X	{"BLO", KOC_opcode, 1, 47 },
X	{"BLS", KOC_opcode, 1, 48 },
X	{"BLT", KOC_opcode, 1, 49 },
X	{"BMI", KOC_opcode, 1, 50 },
X	{"BNE", KOC_opcode, 1, 51 },
X	{"BPL", KOC_opcode, 1, 52 },
X	{"BRA", KOC_opcode, 1, 53 },
X	{"BRN", KOC_opcode, 1, 54 },
X	{"BSR", KOC_opcode, 1, 55 },
X	{"BVC", KOC_opcode, 1, 56 },
X	{"BVS", KOC_opcode, 1, 57 },
X	{"BYTE", KOC_BDEF, 0, 0 },
X	{"CHARDEF", KOC_CHDEF, 0, 0 },
X	{"CHARSET", KOC_CHSET, 0, 0 },
X	{"CHARUSE", KOC_CHUSE, 0, 0 },
X	{"CHD", KOC_CHDEF, 0, 0 },
X	{"CLR", KOC_opcode, 2, 58 },
X	{"CLRA", KOC_opcode, 1, 60 },
X	{"CLRB", KOC_opcode, 1, 61 },
X	{"CMPA", KOC_opcode, 3, 62 },
X	{"CMPB", KOC_opcode, 3, 65 },
X	{"CMPD", KOC_opcode, 3, 68 },
X	{"CMPS", KOC_opcode, 3, 71 },
X	{"CMPU", KOC_opcode, 3, 74 },
X	{"CMPX", KOC_opcode, 3, 77 },
X	{"CMPY", KOC_opcode, 3, 80 },
X	{"COM", KOC_opcode, 2, 83 },
X	{"COMA", KOC_opcode, 1, 85 },
X	{"COMB", KOC_opcode, 1, 86 },
X	{"CWAI", KOC_opcode, 1, 87 },
X	{"DAA", KOC_opcode, 1, 88 },
X	{"DB", KOC_BDEF, 0, 0 },
X	{"DEC", KOC_opcode, 2, 89 },
X	{"DECA", KOC_opcode, 1, 91 },
X	{"DECB", KOC_opcode, 1, 92 },
X	{"DW", KOC_WDEF, 0, 0 },
X	{"ELSE", KOC_ELSE, 0, 0 },
X	{"END", KOC_END, 0, 0 },
X	{"ENDI", KOC_ENDI, 0, 0 },
X	{"EORA", KOC_opcode, 3, 93 },
X	{"EORB", KOC_opcode, 3, 96 },
X	{"EQU", KOC_EQU, 0, 0 },
X	{"EXG", KOC_tfrop, 1, 99 },
X	{"FCB", KOC_BDEF, 0, 0 },
X	{"FCC", KOC_SDEF, 0, 0 },
X	{"FDB", KOC_WDEF, 0, 0 },
X	{"IF", KOC_IF, 0, 0 },
X	{"INC", KOC_opcode, 2, 100 },
X	{"INCA", KOC_opcode, 1, 102 },
X	{"INCB", KOC_opcode, 1, 103 },
X	{"INCL", KOC_INCLUDE, 0, 0 },
X	{"INCLUDE", KOC_INCLUDE, 0, 0 },
X	{"JMP", KOC_opcode, 2, 104 },
X	{"JSR", KOC_opcode, 2, 106 },
X	{"LBCC", KOC_opcode, 1, 108 },
X	{"LBCS", KOC_opcode, 1, 109 },
X	{"LBEQ", KOC_opcode, 1, 110 },
X	{"LBGE", KOC_opcode, 1, 111 },
X	{"LBGT", KOC_opcode, 1, 112 },
X	{"LBHI", KOC_opcode, 1, 113 },
X	{"LBHS", KOC_opcode, 1, 114 },
X	{"LBLE", KOC_opcode, 1, 115 },
X	{"LBLO", KOC_opcode, 1, 116 },
X	{"LBLS", KOC_opcode, 1, 117 },
X	{"LBLT", KOC_opcode, 1, 118 },
X	{"LBMI", KOC_opcode, 1, 119 },
X	{"LBNE", KOC_opcode, 1, 120 },
X	{"LBPL", KOC_opcode, 1, 121 },
X	{"LBRA", KOC_opcode, 1, 122 },
X	{"LBRN", KOC_opcode, 1, 123 },
X	{"LBSR", KOC_opcode, 1, 124 },
X	{"LBVC", KOC_opcode, 1, 125 },
X	{"LBVS", KOC_opcode, 1, 126 },
X	{"LDA", KOC_opcode, 3, 127 },
X	{"LDB", KOC_opcode, 3, 130 },
X	{"LDD", KOC_opcode, 3, 133 },
X	{"LDS", KOC_opcode, 3, 136 },
X	{"LDU", KOC_opcode, 3, 139 },
X	{"LDX", KOC_opcode, 3, 142 },
X	{"LDY", KOC_opcode, 3, 145 },
X	{"LEAS", KOC_opcode, 1, 148 },
X	{"LEAU", KOC_opcode, 1, 149 },
X	{"LEAX", KOC_opcode, 1, 150 },
X	{"LEAY", KOC_opcode, 1, 151 },
X	{"LSL", KOC_opcode, 2, 152 },
X	{"LSLA", KOC_opcode, 1, 154 },
X	{"LSLB", KOC_opcode, 1, 155 },
X	{"LSR", KOC_opcode, 2, 156 },
X	{"LSRA", KOC_opcode, 1, 158 },
X	{"LSRB", KOC_opcode, 1, 159 },
X	{"MUL", KOC_opcode, 1, 160 },
X	{"NEG", KOC_opcode, 2, 161 },
X	{"NEGA", KOC_opcode, 1, 163 },
X	{"NEGB", KOC_opcode, 1, 164 },
X	{"NOP", KOC_opcode, 1, 165 },
X	{"ORA", KOC_opcode, 3, 166 },
X	{"ORB", KOC_opcode, 3, 169 },
X	{"ORCC", KOC_opcode, 1, 172 },
X	{"ORG", KOC_ORG, 0, 0 },
X	{"PSHS", KOC_sstkop, 1, 173 },
X	{"PSHU", KOC_ustkop, 1, 174 },
X	{"PULS", KOC_sstkop, 1, 175 },
X	{"PULU", KOC_ustkop, 1, 176 },
X	{"RESERVE", KOC_RESM, 0, 0 },
X	{"RMB", KOC_RESM, 0, 0 },
X	{"ROL", KOC_opcode, 2, 177 },
X	{"ROLA", KOC_opcode, 1, 179 },
X	{"ROLB", KOC_opcode, 1, 180 },
X	{"ROR", KOC_opcode, 2, 181 },
X	{"RORA", KOC_opcode, 1, 183 },
X	{"RORB", KOC_opcode, 1, 184 },
X	{"RTI", KOC_opcode, 1, 185 },
X	{"RTS", KOC_opcode, 1, 186 },
X	{"SBCA", KOC_opcode, 3, 187 },
X	{"SBCB", KOC_opcode, 3, 190 },
X	{"SET", KOC_SET, 0, 0 },
X	{"SEX", KOC_opcode, 1, 193 },
X	{"STA", KOC_opcode, 2, 194 },
X	{"STB", KOC_opcode, 2, 196 },
X	{"STD", KOC_opcode, 2, 198 },
X	{"STRING", KOC_SDEF, 0, 0 },
X	{"STS", KOC_opcode, 2, 200 },
X	{"STU", KOC_opcode, 2, 202 },
X	{"STX", KOC_opcode, 2, 204 },
X	{"STY", KOC_opcode, 2, 206 },
X	{"SUBA", KOC_opcode, 3, 208 },
X	{"SUBB", KOC_opcode, 3, 211 },
X	{"SUBD", KOC_opcode, 3, 214 },
X	{"SWI2", KOC_opcode, 1, 217 },
X	{"SWI3", KOC_opcode, 1, 218 },
X	{"SWI", KOC_opcode, 1, 219 },
X	{"SYNC", KOC_opcode, 1, 220 },
X	{"TFR", KOC_tfrop, 1, 221 },
X	{"TST", KOC_opcode, 2, 222 },
X	{"TSTA", KOC_opcode, 1, 224 },
X	{"TSTB", KOC_opcode, 1, 225 },
X	{"WORD", KOC_WDEF, 0, 0 },
X	{ "", 0, 0, 0 }};
X
Xstruct opsynt ostab[NUMSYNBLK+1]
X	= {
X/* invalid 0 */ { 0, 1, 0 },
X/* invalid 1 */ { 0xffff, 1, 1 },
X/* ABX 2 */ { ST_INH, 1, 2 },
X/* ADCA 3 */ { ST_EXP, 2, 3 },
X/* ADCA 4 */ { ST_IMM, 1, 5 },
X/* ADCA 5 */ { ST_IND, 1, 6 },
X/* ADCB 6 */ { ST_EXP, 2, 7 },
X/* ADCB 7 */ { ST_IMM, 1, 9 },
X/* ADCB 8 */ { ST_IND, 1, 10 },
X/* ADDA 9 */ { ST_EXP, 2, 11 },
X/* ADDA 10 */ { ST_IMM, 1, 13 },
X/* ADDA 11 */ { ST_IND, 1, 14 },
X/* ADDB 12 */ { ST_EXP, 2, 15 },
X/* ADDB 13 */ { ST_IMM, 1, 17 },
X/* ADDB 14 */ { ST_IND, 1, 18 },
X/* ADDD 15 */ { ST_EXP, 2, 19 },
X/* ADDD 16 */ { ST_IMM, 1, 21 },
X/* ADDD 17 */ { ST_IND, 1, 22 },
X/* ANDA 18 */ { ST_EXP, 2, 23 },
X/* ANDA 19 */ { ST_IMM, 1, 25 },
X/* ANDA 20 */ { ST_IND, 1, 26 },
X/* ANDB 21 */ { ST_EXP, 2, 27 },
X/* ANDB 22 */ { ST_IMM, 1, 29 },
X/* ANDB 23 */ { ST_IND, 1, 30 },
X/* ANDCC 24 */ { ST_IMM, 1, 31 },
X/* ASL 25 */ { ST_EXP, 2, 32 },
X/* ASL 26 */ { ST_IND, 1, 34 },
X/* ASLA 27 */ { ST_INH, 1, 35 },
X/* ASLB 28 */ { ST_INH, 1, 36 },
X/* ASR 29 */ { ST_EXP, 2, 37 },
X/* ASR 30 */ { ST_IND, 1, 39 },
X/* ASRA 31 */ { ST_INH, 1, 40 },
X/* ASRB 32 */ { ST_INH, 1, 41 },
X/* BCC 33 */ { ST_EXP, 1, 42 },
X/* BCS 34 */ { ST_EXP, 1, 43 },
X/* BEQ 35 */ { ST_EXP, 1, 44 },
X/* BGE 36 */ { ST_EXP, 1, 45 },
X/* BGT 37 */ { ST_EXP, 1, 46 },
X/* BHI 38 */ { ST_EXP, 1, 47 },
X/* BHS 39 */ { ST_EXP, 1, 48 },
X/* BITA 40 */ { ST_EXP, 2, 49 },
X/* BITA 41 */ { ST_IMM, 1, 51 },
X/* BITA 42 */ { ST_IND, 1, 52 },
X/* BITB 43 */ { ST_EXP, 2, 53 },
X/* BITB 44 */ { ST_IMM, 1, 55 },
X/* BITB 45 */ { ST_IND, 1, 56 },
X/* BLE 46 */ { ST_EXP, 1, 57 },
X/* BLO 47 */ { ST_EXP, 1, 58 },
X/* BLS 48 */ { ST_EXP, 1, 59 },
X/* BLT 49 */ { ST_EXP, 1, 60 },
X/* BMI 50 */ { ST_EXP, 1, 61 },
X/* BNE 51 */ { ST_EXP, 1, 62 },
X/* BPL 52 */ { ST_EXP, 1, 63 },
X/* BRA 53 */ { ST_EXP, 1, 64 },
X/* BRN 54 */ { ST_EXP, 1, 65 },
X/* BSR 55 */ { ST_EXP, 1, 66 },
X/* BVC 56 */ { ST_EXP, 1, 67 },
X/* BVS 57 */ { ST_EXP, 1, 68 },
X/* CLR 58 */ { ST_EXP, 2, 69 },
X/* CLR 59 */ { ST_IND, 1, 71 },
X/* CLRA 60 */ { ST_INH, 1, 72 },
X/* CLRB 61 */ { ST_INH, 1, 73 },
X/* CMPA 62 */ { ST_EXP, 2, 74 },
X/* CMPA 63 */ { ST_IMM, 1, 76 },
X/* CMPA 64 */ { ST_IND, 1, 77 },
X/* CMPB 65 */ { ST_EXP, 2, 78 },
X/* CMPB 66 */ { ST_IMM, 1, 80 },
X/* CMPB 67 */ { ST_IND, 1, 81 },
X/* CMPD 68 */ { ST_EXP, 2, 82 },
X/* CMPD 69 */ { ST_IMM, 1, 84 },
X/* CMPD 70 */ { ST_IND, 1, 85 },
X/* CMPS 71 */ { ST_EXP, 2, 86 },
X/* CMPS 72 */ { ST_IMM, 1, 88 },
X/* CMPS 73 */ { ST_IND, 1, 89 },
X/* CMPU 74 */ { ST_EXP, 2, 90 },
X/* CMPU 75 */ { ST_IMM, 1, 92 },
X/* CMPU 76 */ { ST_IND, 1, 93 },
X/* CMPX 77 */ { ST_EXP, 2, 94 },
X/* CMPX 78 */ { ST_IMM, 1, 96 },
X/* CMPX 79 */ { ST_IND, 1, 97 },
X/* CMPY 80 */ { ST_EXP, 2, 98 },
X/* CMPY 81 */ { ST_IMM, 1, 100 },
X/* CMPY 82 */ { ST_IND, 1, 101 },
X/* COM 83 */ { ST_EXP, 2, 102 },
X/* COM 84 */ { ST_IND, 1, 104 },
X/* COMA 85 */ { ST_INH, 1, 105 },
X/* COMB 86 */ { ST_INH, 1, 106 },
X/* CWAI 87 */ { ST_IMM, 1, 107 },
X/* DAA 88 */ { ST_INH, 1, 108 },
X/* DEC 89 */ { ST_EXP, 2, 109 },
X/* DEC 90 */ { ST_IND, 1, 111 },
X/* DECA 91 */ { ST_INH, 1, 112 },
X/* DECB 92 */ { ST_INH, 1, 113 },
X/* EORA 93 */ { ST_EXP, 2, 114 },
X/* EORA 94 */ { ST_IMM, 1, 116 },
X/* EORA 95 */ { ST_IND, 1, 117 },
X/* EORB 96 */ { ST_EXP, 2, 118 },
X/* EORB 97 */ { ST_IMM, 1, 120 },
X/* EORB 98 */ { ST_IND, 1, 121 },
X/* EXG 99 */ { ST_TFR, 1, 122 },
X/* INC 100 */ { ST_EXP, 2, 123 },
X/* INC 101 */ { ST_IND, 1, 125 },
X/* INCA 102 */ { ST_INH, 1, 126 },
X/* INCB 103 */ { ST_INH, 1, 127 },
X/* JMP 104 */ { ST_EXP, 2, 128 },
X/* JMP 105 */ { ST_IND, 1, 130 },
X/* JSR 106 */ { ST_EXP, 2, 131 },
X/* JSR 107 */ { ST_IND, 1, 133 },
X/* LBCC 108 */ { ST_EXP, 1, 134 },
X/* LBCS 109 */ { ST_EXP, 1, 135 },
X/* LBEQ 110 */ { ST_EXP, 1, 136 },
X/* LBGE 111 */ { ST_EXP, 1, 137 },
X/* LBGT 112 */ { ST_EXP, 1, 138 },
X/* LBHI 113 */ { ST_EXP, 1, 139 },
X/* LBHS 114 */ { ST_EXP, 1, 140 },
X/* LBLE 115 */ { ST_EXP, 1, 141 },
X/* LBLO 116 */ { ST_EXP, 1, 142 },
X/* LBLS 117 */ { ST_EXP, 1, 143 },
X/* LBLT 118 */ { ST_EXP, 1, 144 },
X/* LBMI 119 */ { ST_EXP, 1, 145 },
X/* LBNE 120 */ { ST_EXP, 1, 146 },
X/* LBPL 121 */ { ST_EXP, 1, 147 },
X/* LBRA 122 */ { ST_EXP, 1, 148 },
X/* LBRN 123 */ { ST_EXP, 1, 149 },
X/* LBSR 124 */ { ST_EXP, 1, 150 },
X/* LBVC 125 */ { ST_EXP, 1, 151 },
X/* LBVS 126 */ { ST_EXP, 1, 152 },
X/* LDA 127 */ { ST_EXP, 2, 153 },
X/* LDA 128 */ { ST_IMM, 1, 155 },
X/* LDA 129 */ { ST_IND, 1, 156 },
X/* LDB 130 */ { ST_EXP, 2, 157 },
X/* LDB 131 */ { ST_IMM, 1, 159 },
X/* LDB 132 */ { ST_IND, 1, 160 },
X/* LDD 133 */ { ST_EXP, 2, 161 },
X/* LDD 134 */ { ST_IMM, 1, 163 },
X/* LDD 135 */ { ST_IND, 1, 164 },
X/* LDS 136 */ { ST_EXP, 2, 165 },
X/* LDS 137 */ { ST_IMM, 1, 167 },
X/* LDS 138 */ { ST_IND, 1, 168 },
X/* LDU 139 */ { ST_EXP, 2, 169 },
X/* LDU 140 */ { ST_IMM, 1, 171 },
X/* LDU 141 */ { ST_IND, 1, 172 },
X/* LDX 142 */ { ST_EXP, 2, 173 },
X/* LDX 143 */ { ST_IMM, 1, 175 },
X/* LDX 144 */ { ST_IND, 1, 176 },
X/* LDY 145 */ { ST_EXP, 2, 177 },
X/* LDY 146 */ { ST_IMM, 1, 179 },
X/* LDY 147 */ { ST_IND, 1, 180 },
X/* LEAS 148 */ { ST_IND, 1, 181 },
X/* LEAU 149 */ { ST_IND, 1, 182 },
X/* LEAX 150 */ { ST_IND, 1, 183 },
X/* LEAY 151 */ { ST_IND, 1, 184 },
X/* LSL 152 */ { ST_EXP, 2, 185 },
X/* LSL 153 */ { ST_IND, 1, 187 },
X/* LSLA 154 */ { ST_INH, 1, 188 },
X/* LSLB 155 */ { ST_INH, 1, 189 },
X/* LSR 156 */ { ST_EXP, 2, 190 },
X/* LSR 157 */ { ST_IND, 1, 192 },
X/* LSRA 158 */ { ST_INH, 1, 193 },
X/* LSRB 159 */ { ST_INH, 1, 194 },
X/* MUL 160 */ { ST_INH, 1, 195 },
X/* NEG 161 */ { ST_EXP, 2, 196 },
X/* NEG 162 */ { ST_IND, 1, 198 },
X/* NEGA 163 */ { ST_INH, 1, 199 },
X/* NEGB 164 */ { ST_INH, 1, 200 },
X/* NOP 165 */ { ST_INH, 1, 201 },
X/* ORA 166 */ { ST_EXP, 2, 202 },
X/* ORA 167 */ { ST_IMM, 1, 204 },
X/* ORA 168 */ { ST_IND, 1, 205 },
X/* ORB 169 */ { ST_EXP, 2, 206 },
X/* ORB 170 */ { ST_IMM, 1, 208 },
X/* ORB 171 */ { ST_IND, 1, 209 },
X/* ORCC 172 */ { ST_IMM, 1, 210 },
X/* PSHS 173 */ { ST_SPSH, 1, 211 },
X/* PSHU 174 */ { ST_UPSH, 1, 212 },
X/* PULS 175 */ { ST_SPSH, 1, 213 },
X/* PULU 176 */ { ST_UPSH, 1, 214 },
X/* ROL 177 */ { ST_EXP, 2, 215 },
X/* ROL 178 */ { ST_IND, 1, 217 },
X/* ROLA 179 */ { ST_INH, 1, 218 },
X/* ROLB 180 */ { ST_INH, 1, 219 },
X/* ROR 181 */ { ST_EXP, 2, 220 },
X/* ROR 182 */ { ST_IND, 1, 222 },
X/* RORA 183 */ { ST_INH, 1, 223 },
X/* RORB 184 */ { ST_INH, 1, 224 },
X/* RTI 185 */ { ST_INH, 1, 225 },
X/* RTS 186 */ { ST_INH, 1, 226 },
X/* SBCA 187 */ { ST_EXP, 2, 227 },
X/* SBCA 188 */ { ST_IMM, 1, 229 },
X/* SBCA 189 */ { ST_IND, 1, 230 },
X/* SBCB 190 */ { ST_EXP, 2, 231 },
X/* SBCB 191 */ { ST_IMM, 1, 233 },
X/* SBCB 192 */ { ST_IND, 1, 234 },
X/* SEX 193 */ { ST_INH, 1, 235 },
X/* STA 194 */ { ST_EXP, 2, 236 },
X/* STA 195 */ { ST_IND, 1, 238 },
X/* STB 196 */ { ST_EXP, 2, 239 },
X/* STB 197 */ { ST_IND, 1, 241 },
X/* STD 198 */ { ST_EXP, 2, 242 },
X/* STD 199 */ { ST_IND, 1, 244 },
X/* STS 200 */ { ST_EXP, 2, 245 },
X/* STS 201 */ { ST_IND, 1, 247 },
X/* STU 202 */ { ST_EXP, 2, 248 },
X/* STU 203 */ { ST_IND, 1, 250 },
X/* STX 204 */ { ST_EXP, 2, 251 },
X/* STX 205 */ { ST_IND, 1, 253 },
X/* STY 206 */ { ST_EXP, 2, 254 },
X/* STY 207 */ { ST_IND, 1, 256 },
X/* SUBA 208 */ { ST_EXP, 2, 257 },
X/* SUBA 209 */ { ST_IMM, 1, 259 },
X/* SUBA 210 */ { ST_IND, 1, 260 },
X/* SUBB 211 */ { ST_EXP, 2, 261 },
X/* SUBB 212 */ { ST_IMM, 1, 263 },
X/* SUBB 213 */ { ST_IND, 1, 264 },
X/* SUBD 214 */ { ST_EXP, 2, 265 },
X/* SUBD 215 */ { ST_IMM, 1, 267 },
X/* SUBD 216 */ { ST_IND, 1, 268 },
X/* SWI2 217 */ { ST_INH, 1, 269 },
X/* SWI3 218 */ { ST_INH, 1, 270 },
X/* SWI 219 */ { ST_INH, 1, 271 },
X/* SYNC 220 */ { ST_INH, 1, 272 },
X/* TFR 221 */ { ST_TFR, 1, 273 },
X/* TST 222 */ { ST_EXP, 2, 274 },
X/* TST 223 */ { ST_IND, 1, 276 },
X/* TSTA 224 */ { ST_INH, 1, 277 },
X/* TSTB 225 */ { ST_INH, 1, 278 },
X	{ 0, 0, 0 } };
X
Xstruct igel igtab[NUMDIFFOP+1]
X	= {
X/* invalid 0 */   { 0 , 0, 
X		"[Xnullentry" },
X/* invalid 1 */   { 0 , 0, 
X		"[Xinvalid opcode" },
X/* ABX 2 */   { 0 , 0, 
X		"3a;" },
X/* ADCA 3 */   { ADDR , DIRECT, 
X		"99;[1=];" },
X/* ADCA 4 */   { ADDR , EXTENDED, 
X		"b9;[1=]x" },
X/* ADCA 5 */   { 0 , 0, 
X		"89;[1=];" },
X/* ADCA 6 */   { 0 , 0, 
X		"a9;" },
X/* ADCB 7 */   { ADDR , DIRECT, 
X		"d9;[1=];" },
X/* ADCB 8 */   { ADDR , EXTENDED, 
X		"f9;[1=]x" },
X/* ADCB 9 */   { 0 , 0, 
X		"c9;[1=];" },
X/* ADCB 10 */   { 0 , 0, 
X		"e9;" },
X/* ADDA 11 */   { ADDR , DIRECT, 
X		"9b;[1=];" },
X/* ADDA 12 */   { ADDR , EXTENDED, 
X		"bb;[1=]x" },
X/* ADDA 13 */   { 0 , 0, 
X		"8b;[1=];" },
X/* ADDA 14 */   { 0 , 0, 
X		"ab;" },
X/* ADDB 15 */   { ADDR , DIRECT, 
X		"db;[1=];" },
X/* ADDB 16 */   { ADDR , EXTENDED, 
X		"fb;[1=]x" },
X/* ADDB 17 */   { 0 , 0, 
X		"cb;[1=];" },
X/* ADDB 18 */   { 0 , 0, 
X		"eb;" },
X/* ADDD 19 */   { ADDR , DIRECT, 
X		"d3;[1=];" },
X/* ADDD 20 */   { ADDR , EXTENDED, 
X		"f3;[1=]x" },
X/* ADDD 21 */   { 0 , 0, 
X		"c3;[1=]x" },
X/* ADDD 22 */   { 0 , 0, 
X		"e3;" },
X/* ANDA 23 */   { ADDR , DIRECT, 
X		"94;[1=];" },
X/* ANDA 24 */   { ADDR , EXTENDED, 
X		"b4;[1=]x" },
X/* ANDA 25 */   { 0 , 0, 
X		"84;[1=];" },
X/* ANDA 26 */   { 0 , 0, 
X		"a4;" },
X/* ANDB 27 */   { ADDR , DIRECT, 
X		"d4;[1=];" },
X/* ANDB 28 */   { ADDR , EXTENDED, 
X		"f4;[1=]x" },
X/* ANDB 29 */   { 0 , 0, 
X		"c4;[1=];" },
X/* ANDB 30 */   { 0 , 0, 
X		"e4;" },
X/* ANDCC 31 */   { 0 , 0, 
X		"1c;[1=];" },
X/* ASL 32 */   { ADDR , DIRECT, 
X		"08;[1=];" },
X/* ASL 33 */   { ADDR , EXTENDED, 
X		"78;[1=]x" },
X/* ASL 34 */   { 0 , 0, 
X		"68;" },
X/* ASLA 35 */   { 0 , 0, 
X		"48;" },
X/* ASLB 36 */   { 0 , 0, 
X		"58;" },
X/* ASR 37 */   { ADDR , DIRECT, 
X		"07;[1=];" },
X/* ASR 38 */   { ADDR , EXTENDED, 
X		"77;[1=]x" },
X/* ASR 39 */   { 0 , 0, 
X		"67;" },
X/* ASRA 40 */   { 0 , 0, 
X		"47;" },
X/* ASRB 41 */   { 0 , 0, 
X		"57;" },
X/* BCC 42 */   { 0 , 0, 
X		"24;[1=].Q.1+-r" },
X/* BCS 43 */   { 0 , 0, 
X		"25;[1=].Q.1+-r" },
X/* BEQ 44 */   { 0 , 0, 
X		"27;[1=].Q.1+-r" },
X/* BGE 45 */   { 0 , 0, 
X		"2c;[1=].Q.1+-r" },
X/* BGT 46 */   { 0 , 0, 
X		"2e;[1=].Q.1+-r" },
X/* BHI 47 */   { 0 , 0, 
X		"22;[1=].Q.1+-r" },
X/* BHS 48 */   { 0 , 0, 
X		"24;[1=].Q.1+-r" },
X/* BITA 49 */   { ADDR , DIRECT, 
X		"95;[1=];" },
X/* BITA 50 */   { ADDR , EXTENDED, 
X		"b5;[1=]x" },
X/* BITA 51 */   { 0 , 0, 
X		"85;[1=];" },
X/* BITA 52 */   { 0 , 0, 
X		"a5;" },
X/* BITB 53 */   { ADDR , DIRECT, 
X		"d5;[1=];" },
X/* BITB 54 */   { ADDR , EXTENDED, 
X		"f5;[1=]x" },
X/* BITB 55 */   { 0 , 0, 
X		"c5;[1=];" },
X/* BITB 56 */   { 0 , 0, 
X		"e5;" },
X/* BLE 57 */   { 0 , 0, 
X		"2f;[1=].Q.1+-r" },
X/* BLO 58 */   { 0 , 0, 
X		"25;[1=].Q.1+-r" },
X/* BLS 59 */   { 0 , 0, 
X		"23;[1=].Q.1+-r" },
X/* BLT 60 */   { 0 , 0, 
X		"2d;[1=].Q.1+-r" },
X/* BMI 61 */   { 0 , 0, 
X		"2b;[1=].Q.1+-r" },
X/* BNE 62 */   { 0 , 0, 
X		"26;[1=].Q.1+-r" },
X/* BPL 63 */   { 0 , 0, 
X		"2a;[1=].Q.1+-r" },
X/* BRA 64 */   { 0 , 0, 
X		"20;[1=].Q.1+-r" },
X/* BRN 65 */   { 0 , 0, 
X		"21;[1=].Q.1+-r" },
X/* BSR 66 */   { 0 , 0, 
X		"8d;[1=].Q.1+-r" },
X/* BVC 67 */   { 0 , 0, 
X		"28;[1=].Q.1+-r" },
X/* BVS 68 */   { 0 , 0, 
X		"29;[1=].Q.1+-r" },
X/* CLR 69 */   { ADDR , DIRECT, 
X		"0f;[1=];" },
X/* CLR 70 */   { ADDR , EXTENDED, 
X		"7f;[1=]x" },
X/* CLR 71 */   { 0 , 0, 
X		"6f;" },
X/* CLRA 72 */   { 0 , 0, 
X		"4f;" },
X/* CLRB 73 */   { 0 , 0, 
X		"5f;" },
X/* CMPA 74 */   { ADDR , DIRECT, 
X		"91;[1=];" },
X/* CMPA 75 */   { ADDR , EXTENDED, 
X		"b1;[1=]x" },
X/* CMPA 76 */   { 0 , 0, 
X		"81;[1=];" },
X/* CMPA 77 */   { 0 , 0, 
X		"a1;" },
X/* CMPB 78 */   { ADDR , DIRECT, 
X		"d1;[1=];" },
X/* CMPB 79 */   { ADDR , EXTENDED, 
X		"f1;[1=]x" },
X/* CMPB 80 */   { 0 , 0, 
X		"c1;[1=];" },
X/* CMPB 81 */   { 0 , 0, 
X		"e1;" },
X/* CMPD 82 */   { ADDR , DIRECT, 
X		"10;93;[1=];" },
X/* CMPD 83 */   { ADDR , EXTENDED, 
X		"10;b3;[1=]x" },
X/* CMPD 84 */   { 0 , 0, 
X		"10;83;[1=]x" },
X/* CMPD 85 */   { 0 , 0, 
X		"10;a3;" },
X/* CMPS 86 */   { ADDR , DIRECT, 
X		"11;9c;[1=];" },
X/* CMPS 87 */   { ADDR , EXTENDED, 
X		"11;bc;[1=]x" },
X/* CMPS 88 */   { 0 , 0, 
X		"11;8c;[1=]x" },
X/* CMPS 89 */   { 0 , 0, 
X		"11;ac;" },
X/* CMPU 90 */   { ADDR , DIRECT, 
X		"11;93;[1=];" },
X/* CMPU 91 */   { ADDR , EXTENDED, 
X		"11;b3;[1=]x" },
X/* CMPU 92 */   { 0 , 0, 
X		"11;83;[1=]x" },
X/* CMPU 93 */   { 0 , 0, 
X		"11;a3;" },
X/* CMPX 94 */   { ADDR , DIRECT, 
X		"9c;[1=];" },
X/* CMPX 95 */   { ADDR , EXTENDED, 
X		"bc;[1=]x" },
X/* CMPX 96 */   { 0 , 0, 
X		"8c;[1=]x" },
X/* CMPX 97 */   { 0 , 0, 
X		"ac;" },
X/* CMPY 98 */   { ADDR , DIRECT, 
X		"10;9c;[1=];" },
X/* CMPY 99 */   { ADDR , EXTENDED, 
X		"10;bc;[1=]x" },
X/* CMPY 100 */   { 0 , 0, 
X		"10;8c;[1=]x" },
X/* CMPY 101 */   { 0 , 0, 
X		"10;ac;" },
X/* COM 102 */   { ADDR , DIRECT, 
X		"03;[1=];" },
X/* COM 103 */   { ADDR , EXTENDED, 
X		"73;[1=]x" },
X/* COM 104 */   { 0 , 0, 
X		"63;" },
X/* COMA 105 */   { 0 , 0, 
X		"43;" },
X/* COMB 106 */   { 0 , 0, 
X		"53;" },
X/* CWAI 107 */   { 0 , 0, 
X		"3c;[1=];" },
X/* DAA 108 */   { 0 , 0, 
X		"19;" },
X/* DEC 109 */   { ADDR , DIRECT, 
X		"0a;[1=];" },
X/* DEC 110 */   { ADDR , EXTENDED, 
X		"7a;[1=]x" },
X/* DEC 111 */   { 0 , 0, 
X		"6a;" },
X/* DECA 112 */   { 0 , 0, 
X		"4a;" },
X/* DECB 113 */   { 0 , 0, 
X		"5a;" },
X/* EORA 114 */   { ADDR , DIRECT, 
X		"98;[1=];" },
X/* EORA 115 */   { ADDR , EXTENDED, 
X		"b8;[1=]x" },
X/* EORA 116 */   { 0 , 0, 
X		"88;[1=];" },
X/* EORA 117 */   { 0 , 0, 
X		"a8;" },
X/* EORB 118 */   { ADDR , DIRECT, 
X		"d8;[1=];" },
X/* EORB 119 */   { ADDR , EXTENDED, 
X		"f8;[1=]x" },
X/* EORB 120 */   { 0 , 0, 
X		"c8;[1=];" },
X/* EORB 121 */   { 0 , 0, 
X		"e8;" },
X/* EXG 122 */   { 0 , 0, 
X		"1e;[1#2#];" },
X/* INC 123 */   { ADDR , DIRECT, 
X		"0c;[1=];" },
X/* INC 124 */   { ADDR , EXTENDED, 
X		"7c;[1=]x" },
X/* INC 125 */   { 0 , 0, 
X		"6c;" },
X/* INCA 126 */   { 0 , 0, 
X		"4c;" },
X/* INCB 127 */   { 0 , 0, 
X		"5c;" },
X/* JMP 128 */   { ADDR , DIRECT, 
X		"0e;[1=];" },
X/* JMP 129 */   { ADDR , EXTENDED, 
X		"7e;[1=]x" },
X/* JMP 130 */   { 0 , 0, 
X		"6e;" },
X/* JSR 131 */   { ADDR , DIRECT, 
X		"9d;[1=];" },
X/* JSR 132 */   { ADDR , EXTENDED, 
X		"bd;[1=]x" },
X/* JSR 133 */   { 0 , 0, 
X		"ad;" },
X/* LBCC 134 */   { 0 , 0, 
X		"10;24;[1=].Q.2+-.ffff&x" },
X/* LBCS 135 */   { 0 , 0, 
X		"10;25;[1=].Q.2+-.ffff&x" },
X/* LBEQ 136 */   { 0 , 0, 
X		"10;27;[1=].Q.2+-.ffff&x" },
X/* LBGE 137 */   { 0 , 0, 
X		"10;2c;[1=].Q.2+-.ffff&x" },
X/* LBGT 138 */   { 0 , 0, 
X		"10;2e;[1=].Q.2+-.ffff&x" },
X/* LBHI 139 */   { 0 , 0, 
X		"10;22;[1=].Q.2+-.ffff&x" },
X/* LBHS 140 */   { 0 , 0, 
X		"10;24;[1=].Q.2+-.ffff&x" },
X/* LBLE 141 */   { 0 , 0, 
X		"10;2f;[1=].Q.2+-.ffff&x" },
X/* LBLO 142 */   { 0 , 0, 
X		"10;25;[1=].Q.2+-.ffff&x" },
X/* LBLS 143 */   { 0 , 0, 
X		"10;23;[1=].Q.2+-.ffff&x" },
X/* LBLT 144 */   { 0 , 0, 
X		"10;2d;[1=].Q.2+-.ffff&x" },
X/* LBMI 145 */   { 0 , 0, 
X		"10;2b;[1=].Q.2+-.ffff&x" },
X/* LBNE 146 */   { 0 , 0, 
X		"10;26;[1=].Q.2+-.ffff&x" },
X/* LBPL 147 */   { 0 , 0, 
X		"10;2a;[1=].Q.2+-.ffff&x" },
X/* LBRA 148 */   { 0 , 0, 
X		"16;[1=].Q.2+-.ffff&x" },
X/* LBRN 149 */   { 0 , 0, 
X		"10;21;[1=].Q.2+-.ffff&x" },
X/* LBSR 150 */   { 0 , 0, 
X		"17;[1=].Q.2+-.ffff&x" },
X/* LBVC 151 */   { 0 , 0, 
X		"10;28;[1=].Q.2+-.ffff&x" },
X/* LBVS 152 */   { 0 , 0, 
X		"10;29;[1=].Q.2+-.ffff&x" },
X/* LDA 153 */   { ADDR , DIRECT, 
X		"96;[1=];" },
X/* LDA 154 */   { ADDR , EXTENDED, 
X		"b6;[1=]x" },
X/* LDA 155 */   { 0 , 0, 
X		"86;[1=];" },
X/* LDA 156 */   { 0 , 0, 
X		"a6;" },
X/* LDB 157 */   { ADDR , DIRECT, 
X		"d6;[1=];" },
X/* LDB 158 */   { ADDR , EXTENDED, 
X		"f6;[1=]x" },
X/* LDB 159 */   { 0 , 0, 
X		"c6;[1=];" },
X/* LDB 160 */   { 0 , 0, 
X		"e6;" },
X/* LDD 161 */   { ADDR , DIRECT, 
X		"dc;[1=];" },
X/* LDD 162 */   { ADDR , EXTENDED, 
X		"fc;[1=]x" },
X/* LDD 163 */   { 0 , 0, 
X		"cc;[1=]x" },
X/* LDD 164 */   { 0 , 0, 
X		"ec;" },
X/* LDS 165 */   { ADDR , DIRECT, 
X		"10;de;[1=];" },
X/* LDS 166 */   { ADDR , EXTENDED, 
X		"10;fe;[1=]x" },
X/* LDS 167 */   { 0 , 0, 
X		"10;ce;[1=]x" },
X/* LDS 168 */   { 0 , 0, 
X		"10;ee;" },
X/* LDU 169 */   { ADDR , DIRECT, 
X		"de;[1=];" },
X/* LDU 170 */   { ADDR , EXTENDED, 
X		"fe;[1=]x" },
X/* LDU 171 */   { 0 , 0, 
X		"ce;[1=]x" },
X/* LDU 172 */   { 0 , 0, 
X		"ee;" },
X/* LDX 173 */   { ADDR , DIRECT, 
X		"9e;[1=];" },
X/* LDX 174 */   { ADDR , EXTENDED, 
X		"be;[1=]x" },
X/* LDX 175 */   { 0 , 0, 
X		"8e;[1=]x" },
X/* LDX 176 */   { 0 , 0, 
X		"ae;" },
X/* LDY 177 */   { ADDR , DIRECT, 
X		"10;9e;[1=];" },
X/* LDY 178 */   { ADDR , EXTENDED, 
X		"10;be;[1=]x" },
X/* LDY 179 */   { 0 , 0, 
X		"10;8e;[1=]x" },
X/* LDY 180 */   { 0 , 0, 
X		"10;ae;" },
X/* LEAS 181 */   { 0 , 0, 
X		"32;" },
X/* LEAU 182 */   { 0 , 0, 
X		"33;" },
X/* LEAX 183 */   { 0 , 0, 
X		"30;" },
X/* LEAY 184 */   { 0 , 0, 
X		"31;" },
X/* LSL 185 */   { ADDR , DIRECT, 
X		"08;[1=];" },
X/* LSL 186 */   { ADDR , EXTENDED, 
X		"78;[1=]x" },
X/* LSL 187 */   { 0 , 0, 
X		"68;" },
X/* LSLA 188 */   { 0 , 0, 
X		"48;" },
X/* LSLB 189 */   { 0 , 0, 
X		"58;" },
X/* LSR 190 */   { ADDR , DIRECT, 
X		"04;[1=];" },
X/* LSR 191 */   { ADDR , EXTENDED, 
X		"74;[1=]x" },
X/* LSR 192 */   { 0 , 0, 
X		"64;" },
X/* LSRA 193 */   { 0 , 0, 
X		"44;" },
X/* LSRB 194 */   { 0 , 0, 
X		"54;" },
X/* MUL 195 */   { 0 , 0, 
X		"3d;" },
X/* NEG 196 */   { ADDR , DIRECT, 
X		"00;[1=];" },
X/* NEG 197 */   { ADDR , EXTENDED, 
X		"70;[1=]x" },
X/* NEG 198 */   { 0 , 0, 
X		"60;" },
X/* NEGA 199 */   { 0 , 0, 
X		"40;" },
X/* NEGB 200 */   { 0 , 0, 
X		"50;" },
X/* NOP 201 */   { 0 , 0, 
X		"12;" },
X/* ORA 202 */   { ADDR , DIRECT, 
X		"9a;[1=];" },
X/* ORA 203 */   { ADDR , EXTENDED, 
X		"ba;[1=]x" },
X/* ORA 204 */   { 0 , 0, 
X		"8a;[1=];" },
X/* ORA 205 */   { 0 , 0, 
X		"aa;" },
X/* ORB 206 */   { ADDR , DIRECT, 
X		"da;[1=];" },
X/* ORB 207 */   { ADDR , EXTENDED, 
X		"fa;[1=]x" },
X/* ORB 208 */   { 0 , 0, 
X		"ca;[1=];" },
X/* ORB 209 */   { 0 , 0, 
X		"ea;" },
X/* ORCC 210 */   { 0 , 0, 
X		"1a;[1=];" },
X/* PSHS 211 */   { 0 , 0, 
X		"34;[1#];" },
X/* PSHU 212 */   { 0 , 0, 
X		"36;[1#];" },
X/* PULS 213 */   { 0 , 0, 
X		"35;[1#];" },
X/* PULU 214 */   { 0 , 0, 
X		"37;[1#];" },
X/* ROL 215 */   { ADDR , DIRECT, 
X		"09;[1=];" },
X/* ROL 216 */   { ADDR , EXTENDED, 
X		"79;[1=]x" },
X/* ROL 217 */   { 0 , 0, 
X		"69;" },
X/* ROLA 218 */   { 0 , 0, 
X		"49;" },
X/* ROLB 219 */   { 0 , 0, 
X		"59;" },
X/* ROR 220 */   { ADDR , DIRECT, 
X		"06;[1=];" },
X/* ROR 221 */   { ADDR , EXTENDED, 
X		"76;[1=]x" },
X/* ROR 222 */   { 0 , 0, 
X		"66;" },
X/* RORA 223 */   { 0 , 0, 
X		"46;" },
X/* RORB 224 */   { 0 , 0, 
X		"56;" },
X/* RTI 225 */   { 0 , 0, 
X		"3b;" },
X/* RTS 226 */   { 0 , 0, 
X		"39;" },
X/* SBCA 227 */   { ADDR , DIRECT, 
X		"92;[1=];" },
X/* SBCA 228 */   { ADDR , EXTENDED, 
X		"b2;[1=]x" },
X/* SBCA 229 */   { 0 , 0, 
X		"82;[1=];" },
X/* SBCA 230 */   { 0 , 0, 
X		"a2;" },
X/* SBCB 231 */   { ADDR , DIRECT, 
X		"d2;[1=];" },
X/* SBCB 232 */   { ADDR , EXTENDED, 
X		"f2;[1=]x" },
X/* SBCB 233 */   { 0 , 0, 
X		"c2;[1=];" },
X/* SBCB 234 */   { 0 , 0, 
X		"e2;" },
X/* SEX 235 */   { 0 , 0, 
X		"1d;" },
X/* STA 236 */   { ADDR , DIRECT, 
X		"97;[1=];" },
X/* STA 237 */   { ADDR , EXTENDED, 
X		"b7;[1=]x" },
X/* STA 238 */   { 0 , 0, 
X		"a7;" },
X/* STB 239 */   { ADDR , DIRECT, 
X		"d7;[1=];" },
X/* STB 240 */   { ADDR , EXTENDED, 
X		"f7;[1=]x" },
X/* STB 241 */   { 0 , 0, 
X		"e7;" },
X/* STD 242 */   { ADDR , DIRECT, 
X		"dd;[1=];" },
X/* STD 243 */   { ADDR , EXTENDED, 
X		"fd;[1=]x" },
X/* STD 244 */   { 0 , 0, 
X		"ed;" },
X/* STS 245 */   { ADDR , DIRECT, 
X		"10;df;[1=];" },
X/* STS 246 */   { ADDR , EXTENDED, 
X		"10;ff;[1=]x" },
X/* STS 247 */   { 0 , 0, 
X		"10;ef;" },
X/* STU 248 */   { ADDR , DIRECT, 
X		"df;[1=];" },
X/* STU 249 */   { ADDR , EXTENDED, 
X		"ff;[1=]x" },
X/* STU 250 */   { 0 , 0, 
X		"ef;" },
X/* STX 251 */   { ADDR , DIRECT, 
X		"9f;[1=];" },
X/* STX 252 */   { ADDR , EXTENDED, 
X		"bf;[1=]x" },
X/* STX 253 */   { 0 , 0, 
X		"af;" },
X/* STY 254 */   { ADDR , DIRECT, 
X		"10;9f;[1=];" },
X/* STY 255 */   { ADDR , EXTENDED, 
X		"10;bf;[1=]x" },
X/* STY 256 */   { 0 , 0, 
X		"10;af;" },
X/* SUBA 257 */   { ADDR , DIRECT, 
X		"90;[1=];" },
X/* SUBA 258 */   { ADDR , EXTENDED, 
X		"b0;[1=]x" },
X/* SUBA 259 */   { 0 , 0, 
X		"80;[1=];" },
X/* SUBA 260 */   { 0 , 0, 
X		"a0;" },
X/* SUBB 261 */   { ADDR , DIRECT, 
X		"d0;[1=];" },
X/* SUBB 262 */   { ADDR , EXTENDED, 
X		"f0;[1=]x" },
X/* SUBB 263 */   { 0 , 0, 
X		"c0;[1=];" },
X/* SUBB 264 */   { 0 , 0, 
X		"e0;" },
X/* SUBD 265 */   { ADDR , DIRECT, 
X		"93;[1=];" },
X/* SUBD 266 */   { ADDR , EXTENDED, 
X		"b3;[1=]x" },
X/* SUBD 267 */   { 0 , 0, 
X		"83;[1=]x" },
X/* SUBD 268 */   { 0 , 0, 
X		"a3;" },
X/* SWI2 269 */   { 0 , 0, 
X		"10;3f;" },
X/* SWI3 270 */   { 0 , 0, 
X		"11;3f;" },
X/* SWI 271 */   { 0 , 0, 
X		"3f;" },
X/* SYNC 272 */   { 0 , 0, 
X		"13;" },
X/* TFR 273 */   { 0 , 0, 
X		"1f;[1#2#];" },
X/* TST 274 */   { ADDR , DIRECT, 
X		"0d;[1=];" },
X/* TST 275 */   { ADDR , EXTENDED, 
X		"7d;[1=]x" },
X/* TST 276 */   { 0 , 0, 
X		"6d;" },
X/* TSTA 277 */   { 0 , 0, 
X		"4d;" },
X/* TSTB 278 */   { 0 , 0, 
X		"5d;" },
X	{ 0,0,""} };
X/* end fraptabdef.c */
SHAR_EOF
true || echo 'restore of as6809.y failed'
fi
exit 0
